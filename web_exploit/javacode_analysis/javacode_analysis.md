# CTF Write-Up: [Java Code Analysis][Web Exploitation]

## Description
> BookShelf Pico, my premium online book-reading service.
I believe that my website is super secure. I challenge you to prove me wrong by reading the 'Flag' book!
Additional details will be available after launching your challenge instance.


## Flag
The flag you obtained after solving the challenge. (e.g., `picoCTF{w34k_jwt_n0t_g00d_d72df65e}`)

## Difficulty
- **Difficulty Level:** medium

## Tools Used
- Burpsuite
- https://jwt.io/
- Cyberchef

## Write-Up

### Preparatory Phase
Opening up the website and using the given login we are greeted with a bookstore: ![alt text](image.png)
It was a natural choice to attempt to open the "flag" book, however we were blocked by a 'admin' wall:![alt text](image-1.png) This suggested a need to escalate our powers from a user to admin in the eyes of the server. 

Upon static analysis of the code base I notice the use of Java Web Tokens (JWT). I am relatively inexperienced with web application security and therefore had to conduct some research into what they were. From my high-level understanding they are used to authenticate the identity of clients on its server. It also manages access control namely it differentiates between 'admins' and normal 'users'.

Within `inspect element` $\rightarrow$ `application` $\rightarrow$ `local storage` I find: ![alt text](image-10.png)
My instinct is to modify this such that I obtain admin status.

### Attack Phase
Utilising Burpsuite, I logged in and noticed:
![alt text](image-2.png)
I didn't know what a Bearer was so I searched up "Bearer authorisation" on Google and found this [article](#https://medium.com/@arunchaitanya/wtf-is-bearer-token-an-in-depth-explanation-60695b581928). Running `grep -rio "bearer" .` (-r for recursively search, -i for case-insensitive, -o to just print matches, '.' to search within current directory) I found: 
![alt text](image-3.png)
It appeared that the cryptic string was likely a Java Web Token, so therefore using `jwt.io`, I pasted the Base64 number and received: ![alt text](image-4.png)

At this stage my main goal was to forge a new token such that I was elevated in privileges. In order to achieve this I needed to search for the secret. Using the power of `grep -rio "secret" .` I found the following: ![alt text](image-5.png) 

Within the `SecretGenerator.java` file I discovered an interesting 'secret': ![alt text](image-6.png) The random string generated appeared to just be `1234` and it was commented by the creators of the challenge `not so random`. This function is called during: ![alt text](image-8.png)
It is within a try-catch block whereby the program attempts to read from a secret file which seemingly does not exist in the given code. Otherwise, it obtains our secret as '1234' in the catch block. 

Now following to where this SecretGenerator class is called I find that the HMAC256 algorithm is seeded with the 'secret': ![alt text](image-7.png)

Now that I potentially know the secret key, I need to know how to escalate my powers. I assume the name would be 'admin, therefore I conducted `grep -rio "admin" .` and find ![alt text](image-9.png)

Now I have all the pieces I can to conjure up a potential attack. 

Using jwt.io I input the 'secret' as `1234` and set the role to be `Admin` and `userId` as 2. The reason for this is because there appeared to be two roles: Free and Admin. 
![alt text](image-13.png)
> I assume Free = 1, Admin = 2.

![alt text](image-14.png)
I then went into inspect element again and modifited the token and payload. Upon refreshing the page I obtain: 
![alt text](image-12.png)
### Final Solution/Payload
JWT Token: `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoiQWRtaW4iLCJpc3MiOiJib29rc2hlbGYiLCJleHAiOjE3MzAwMDk4ODAsImlhdCI6MTcyOTQwNTA4MCwidXNlcklkIjoyLCJlbWFpbCI6InVzZXIifQ.EViNo-g42aFcVT3xendI7dC2YsTicD6xR2IwDBizHxc`

### Lessons Learnt
- 
## References
- Link to any external resources, write-ups, or documentation that were helpful in solving the challenge.

